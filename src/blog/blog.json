[{"fileName":"vueRouter-hash模式和history模式.md","content":"<h2>1.hash模式</h2>\n<p>这里的hash就是指url尾巴后的 # 号以及后面的字符。这里的 # 和css里的 # 是一个意思。hash也称作锚点，本身是用来做页面定位的，他可以使对应的id元素显示在可视区域内。</p>\n<p>特点：hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。</p>\n<p>监听hash值变化</p>\n<pre><code>// 浏览器url不包含hash值 基于hash模式的vueRouter在hash值改变后不会影响url,页面不会进行刷新\n  // 监听hash值改变后重新刷新浏览器\n  window.onhashchange = function () {\n    if (window.location.hash.includes(&#39;guidePage&#39;)) {\n      window.location.reload()\n    }\n  }\n</code></pre>\n<p>由于hash值变化不会导致浏览器向服务器发出请求，而且hash改变会触发hashchange事件，浏览器的进后退也能对其进行控制，所以人们在html5的history出现前，基本都是使用hash来实现前端路由的。他的特点在于：hash虽然出现url中，但不会被包含在HTTP请求中，对后端完全没有影响，因此改变hash不会重新加载页面。hash 本来是拿来做页面定位的，如果拿来做路由的话，原来的锚点功能就不能用了。其次，hash的而传参是基于url的，如果要传递复杂的数据，会有体积的限制.</p>\n<h2>2.history模式</h2>\n<p>history模式不仅可以在url里放参数，还可以将数据存放在一个特定的对象中。\nhistory———利用了HTML5 History Interface 中新增的pushState（）和replaceState（）方法。（需要特定浏览器的支持，history不能运用与IE8一下）</p>\n<p>这两个方法应用于浏览器的历史记录栈，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改时，虽然改变了当前的 URL，但浏览器不会立即向后端发送请求。</p>\n<p>因此可以说，hash 模式和 history 模式都属于浏览器自身的特性，Vue-Router 只是利用了这两个特性（通过调用浏览器提供的接口）来实现前端路由。</p>\n<h3>注意</h3>\n<p>history模式下，前端的url必须和实际后端发起请求的url一致，如<a href=\"http://www.abc.com/book/id\">http://www.abc.com/book/id</a> 。如果后端缺少对/book/id 的路由处理，将返回404错误。\nhistory模式下vue.config.js中publicPath不支持./相对路径</p>\n"},{"fileName":"vuex模块化使用.md","content":"<h3>vuex模块化使用</h3>\n<p>store结构</p>\n<ul>\n<li>store<ul>\n<li>index.js</li>\n<li>modules<ul>\n<li>d2admin<ul>\n<li>index.js</li>\n<li>modules<ul>\n<li>log.js</li>\n<li>zoomGlobal.js</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><code>index.js</code></p>\n<pre><code class=\"language-js\">import Vue from &#39;vue&#39;\nimport Vuex from &#39;vuex&#39;\n\nimport d2admin from &#39;./modules/d2admin&#39;\n\nVue.use(Vuex)\n\nexport default new Vuex.Store({\n  modules: {\n    d2admin\n  }\n})\n</code></pre>\n<p><code>modules/d2admin/index.js</code></p>\n<pre><code class=\"language-js\">/**\n * The file enables `@/store/index.js` to import all vuex modules\n * in a one-shot manner. There should not be any reason to edit this file.\n */\n\nconst files = require.context(&#39;./modules&#39;, false, /\\.js$/)\nconst modules = {}\n\nfiles.keys().forEach(key =&gt; {\n  modules[key.replace(/(\\.\\/|\\.js)/g, &#39;&#39;)] = files(key).default\n})\n\nexport default {\n  namespaced: true,\n  modules\n}\n</code></pre>\n<p><code>modules/d2admin/modules/log.js</code></p>\n<pre><code class=\"language-js\">import dayjs from &#39;dayjs&#39;\nimport { get, toString } from &#39;lodash&#39;\nimport util from &#39;@/libs/util.js&#39;\n\nexport default {\n  namespaced: true,\n  state: {\n    // 错误日志\n    list: []\n  },\n  getters: {\n    /**\n     * @description 返回现存 log (all) 的条数\n     * @param {*} state vuex state\n     */\n    length (state) {\n      return state.list.length\n    },\n    /**\n     * @description 返回现存 log (error) 的条数\n     * @param {*} state vuex state\n     */\n    lengthError (state) {\n      return state.list.filter(l =&gt; l.type === &#39;error&#39;).length\n    }\n  },\n  actions: {\n    /**\n     * @description 添加一个日志\n     * @param {Object} param type {String} 类型\n     * @param {Object} param err {Error} 错误对象\n     * @param {Object} param instance {Object} vue 实例\n     * @param {Object} param info {String} 信息\n     */\n    add ({ state, rootState }, { type, err, instance, info }) {\n      // store 赋值\n      state.list.push(Object.assign({\n        // 记录类型 &quot;log&quot; or &quot;error&quot;\n        type: &#39;log&#39;,\n        // 信息\n        info: &#39;&#39;,\n        // 错误对象\n        err: &#39;&#39;,\n        // vue 实例\n        instance: &#39;&#39;,\n        // 当前用户信息\n        user: rootState.d2admin.user.info,\n        // 当前用户的 uuid\n        uuid: util.cookies.get(&#39;uuid&#39;),\n        // 当前的 token\n        token: util.cookies.get(&#39;token&#39;),\n        // 当前地址\n        url: get(window, &#39;location.href&#39;, &#39;&#39;),\n        // 当前时间\n        time: dayjs().format(&#39;YYYY-M-D HH:mm:ss&#39;)\n      }, {\n        type,\n        err,\n        instance,\n        info: toString(info)\n      }))\n    }\n  },\n  mutations: {\n    /**\n     * @description 清空日志\n     * @param {Object} state vuex state\n     */\n    clean (state) {\n      // store 赋值\n      state.list = []\n    }\n  }\n}\n</code></pre>\n<p><code>自己写的保存和读取主框架zoom缩放 zoomGlobal</code></p>\n<pre><code class=\"language-js\">export default {\n    namespaced: true,\n    state:{\n        zoom:1,\n    },\n    getters:{\n        getZoom(state) {\n            return state.zoom\n        }\n    },\n    mutations:{\n        setZoom (state,zoom) {\n            state.zoom = zoom\n        }\n    }\n}\n</code></pre>\n<blockquote>\n<p>使用</p>\n</blockquote>\n<pre><code class=\"language-js\">import { mapState, mapActions } from &#39;vuex&#39;\nexport default {\n       created () {\n        //根据窗口缩放比例对页面进行缩放\n        this.$store.commit(&#39;d2admin/zoomGlobal/setZoom&#39;, 1 * window.devicePixelRatio)\n      },\n    computed: {\n           ...mapState(&#39;d2admin/menu&#39;, [&#39;header&#39;]),\n        ...mapState(&#39;d2admin/user&#39;, [&#39;info&#39;]),\n        ...mapGetters(&#39;d2admin&#39;, {logLength: &#39;log/length&#39;,logLengthError: &#39;log/lengthError&#39;}),\n      },\n    methods: {\n        ...mapActions(&#39;d2admin/account&#39;, [&#39;logout&#39;]),\n        ...mapMutations(&#39;d2admin/log&#39;, [&#39;clean&#39;]),\n      }, \n}\n\n</code></pre>\n"},{"fileName":"vue中的.capture修饰符.md","content":"<p>capture 抓取/捕获</p>\n<pre><code>&lt;button @click.capture.stop=&quot;click()&quot;&gt;&lt;/button&gt;\n</code></pre>\n<h2>.capture事件修饰符的作用添加事件侦听器时使用事件捕获模式</h2>\n<ul>\n<li>即是给元素添加一个监听器，当元素发生冒泡时，先触发带有该修饰符的元素。若有多个该修饰符，则由外而内触发。\n就是谁有该事件修饰符，就先触发谁。</li>\n</ul>\n<h2>.stop 阻止单击事件继续传播</h2>\n"},{"fileName":"vue亚马逊云AWS SDK对接封装.md","content":"<p>使用亚马逊云的AWS3sdk实现云存储对接，作为最大的云存储服务商国内腾讯的cos阿里的alicos以及minio\n都兼容亚马逊的sdk，这样在对接时可减少很多工作量，同时也支持在服务商间快速切换</p>\n<h3>说明</h3>\n<p><code>cacheStsInfo</code>为由后端返回的sts配置信息，根据实际业务需要，具体信息包含\n<img src=\"https://img2023.cnblogs.com/blog/2483371/202305/2483371-20230529150903058-2034294158.png\" alt=\"\"></p>\n<p>以上数据最后由前端缓存下来后，每次使用时根据过期时间进行判断，过期后在重新请求(此处缓存的逻辑代码忽略，自行实现即可)</p>\n<p><code>ProxyAWS</code>为单例模式代理</p>\n<p><code>binconv</code>为安装的插件 ，AWS sdk读取文件时返回的是readableStream，binconv的作用就是将readableStream 转换成blob，</p>\n<p><code>createFileKey</code>和<code>randomNum</code>是根据用户id,桶名生成文件名的方法（根据实际业务需要进行调整）</p>\n<pre><code>import { cacheStsInfo } from &#39;./cacheStsInfo&#39;\nimport S3 from &#39;aws-sdk/clients/s3&#39;\nimport * as binconv from &#39;binconv&#39;\nimport { Message } from &#39;element-ui&#39;\n\nlet ProxyAWS = (function () {\n  let instance\n  return function (info) {\n    if (!instance) {\n      instance = new S3({\n        endpoint: info.ossInfo.endpoint,\n        accessKeyId: info.credentials.tmpAccessKey,\n        secretAccessKey: info.credentials.tmpSecretKey,\n        sessionToken: info.credentials.sessionToken,\n        s3ForcePathStyle: true, // 使用路径样式访问\n        signatureVersion: &#39;v4&#39; // 使用v4签名版本\n      })\n    }\n    return instance\n  }\n})()\n\nconst uploader = {\n  getUrl: async function (objectId) {\n    let info = await cacheStsInfo()\n    const s3 = new ProxyAWS(info)\n    return new Promise((resolve, reject) =&gt; {\n      s3.getObject({ Bucket: info.ossInfo.bucket, Key: objectId }, async function (error, fileData) {\n        if (!error) {\n          console.log(fileData, &#39;file&#39;)\n          // 将readableStream 转换成blob\n          const blob = await binconv.readableStreamToBlob(fileData.Body)\n          const newBlob = new Blob([blob], { type: fileData.ContentType })\n          let url = window.URL.createObjectURL(newBlob)\n          resolve(url)\n        } else {\n          console.log(error, &#39; ERROR &#39;)\n        }\n      })\n    })\n  },\n  uploadFile: async function (file, filename, objectId = &#39;&#39;) {\n    let info = await cacheStsInfo()\n    if (objectId === &#39;&#39; || objectId === undefined) {\n      objectId = createFileKey(info.permissionPath, filename)\n    }\n    const s3 = new ProxyAWS(info)\n    s3.upload({ Bucket: info.ossInfo.bucket, Key: objectId, Body: file }, (err, data) =&gt; {\n      if (err) {\n        console.log(err)\n        Message.error(&#39;上传失败&#39;)\n      } else {\n        console.log(data)\n        Message.success(&#39;上传成功&#39;)\n      }\n    })\n    let params = {\n      Bucket: info.ossInfo.bucket, Key: objectId, Expires: 3600\n    }\n    let url = s3.getSignedUrl(&#39;getObject&#39;, params)\n    return { objectId, url }\n  }\n}\n\n/* 生成上传到桶中filepath，也就是存库的objectId*/\nfunction createFileKey (permissionPath, filename) {\n  let fileType = filename.substring(filename.lastIndexOf(&#39;.&#39;))\n  return `${permissionPath + randomNum(6)}${parseInt(Math.floor(Math.random() * Date.now()) / 1000)}${fileType}`\n}\n\nconst randomNum = (len) =&gt; {\n  len = len || 32\n  let chars = &#39;ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz&#39;\n  let maxPos = chars.length\n  let rnd = &#39;&#39;\n  for (let i = 0; i &lt; len; i++) {\n    rnd += chars.charAt(Math.floor(Math.random() * maxPos))\n  }\n  return rnd\n}\n\nexport default uploader\n</code></pre>\n"},{"fileName":"vue拖拽指令.md","content":"<pre><code>Vue.directive(&#39;drag&#39;, {\n  // 1.指令绑定到元素上回立刻执行bind函数，只执行一次\n  // 2.每个函数中第一个参数永远是el，表示绑定指令的元素，el参数是原生js对象\n  // 3.通过el.focus()是无法获取焦点的，因为只有插入DOM后才生效\n  bind: function(el) {},\n  // inserted表示一个元素，插入到DOM中会执行inserted函数，只触发一次\n  inserted: function(el) {\n    const odiv = el // 获取当前元素\n    let firstTime = &#39;&#39;\n    let lastTime = &#39;&#39;\n    el.onmousedown = function(e) {\n      var disx = e.pageX - el.offsetLeft\n      var disy = e.pageY - el.offsetTop\n      // 给当前元素添加属性，用于元素状态的判断\n      odiv.setAttribute(&#39;ele-flag&#39;, false)\n      odiv.setAttribute(&#39;draging-flag&#39;, true)\n      firstTime = new Date().getTime()\n      document.onmousemove = function(e) {\n        el.style.left = e.pageX - disx + &#39;px&#39;\n        el.style.top = e.pageY - disy + &#39;px&#39;\n      }\n      document.onmouseup = function(event) {\n        document.onmousemove = document.onmouseup = null\n        lastTime = new Date().getTime()\n        if (lastTime - firstTime &gt; 200) {\n          odiv.setAttribute(&#39;ele-flag&#39;, true)\n          event.stopPropagation()\n        }\n        setTimeout(function() {\n          odiv.setAttribute(&#39;draging-flag&#39;, false)\n        }, 100)\n      }\n    }\n  },\n})\n</code></pre>\n"},{"fileName":"vue组件内使用sass变量.md","content":"<pre><code>&lt;style lang=&quot;scss&quot; scoped&gt;\n\n@import &quot;~@/styles/variables.scss&quot;;\n.fixed-header {\n  background-color: $documentBg;\n  width: calc(100% - #{$sideBarWidth});\n}\n\n\n&lt;/style&gt;\n</code></pre>\n<pre><code>&lt;template&gt;\n  &lt;div :active-text-color=&quot;variables.menuActiveText&quot;&gt;&lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nimport variables from &#39;@/styles/variables.scss&#39;\n&lt;/script&gt;\n</code></pre>\n"},{"fileName":"vue项目通过外部配置文件读取接口地址- 在webpack-index.html模板中使用环境变量.md","content":"<p>概述：在index.html模板中判断当前环境，处于开发环境下时读取process环境变量、处于生产环境下时读取根目录配置文件（./config.js）,两种环境下将配置统一挂载到window全局变量上（SET_CONFIG）\n<code>config.js</code></p>\n<pre><code>window.SITE_CONFIG = {\n  appTitle: &#39;系统测试&#39;,\n  version: &#39;1.0.0&#39;,\n  apiURL: &#39;&#39;,\n  websocketURL: &#39;&#39;,\n  reportURL: &#39;&#39;\n}\n</code></pre>\n<p><code>index.html</code></p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;utf-8&quot;/&gt;\n  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;/&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&quot;/&gt;\n  &lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;/&gt;\n  &lt;title&gt;&lt;%= VUE_APP_TITLE %&gt;&lt;/title&gt;\n  &lt;% if (process.env.NODE_ENV === &#39;production&#39; ) { %&gt;\n  &lt;script type=&quot;text/javascript&quot; src=&quot;config.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    document.title = window.SITE_CONFIG.appTitle\n  &lt;/script&gt;\n  &lt;% } %&gt;\n  &lt;!--    其他环境读取环境变量--&gt;\n  &lt;% if (process.env.NODE_ENV !== &#39;production&#39; ) { %&gt;\n  &lt;script&gt;\n    window.SITE_CONFIG = {};\n    window.SITE_CONFIG[&#39;appTitle&#39;] = &#39;&lt;%= process.env.VUE_APP_TITLE %&gt;&#39;;\n    window.SITE_CONFIG[&#39;version&#39;] = &#39;&lt;%= process.env.VUE_APP_VERSION %&gt;&#39;;\n    window.SITE_CONFIG[&#39;apiURL&#39;] = &#39;&lt;%= process.env.VUE_APP_API %&gt;&#39;;\n    window.SITE_CONFIG[&#39;websocketURL&#39;] = &#39;&lt;%= process.env.VUE_APP_API_WEBSOCKET %&gt;&#39;\n    window.SITE_CONFIG[&#39;VUE_APP_API_REPORT&#39;] = &#39;&lt;%= process.env.VUE_APP_API_REPORT %&gt;&#39;\n  &lt;/script&gt;\n  &lt;% } %&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;noscript&gt;\n  &lt;strong&gt;We&#39;re sorry but &lt;%= webpackConfig.name %&gt; doesn&#39;t work properly without JavaScript enabled. Please enable it to continue.&lt;/strong&gt;\n&lt;/noscript&gt;\n&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;\n&lt;!-- built files will be auto injected --&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h4>注意！！！</h4>\n<h3>当env文件不是默认的.env.development或.env.production而是带有自定义模式的后缀时</h3>\n<h3>例如.env.prod 执行命令为vue-cli-service build --mode prod</h3>\n<h3>此时需要在.env.prod中手动指定构建模式</h3>\n<h3>NODE_ENV=production</h3>\n"}]