[{"fileName":"vue-实现迷你观察者.md","content":"<pre><code>\nclass Dep {\n    constructor() {\n        // 订阅任务队列，方式有相同的任务，用Set数据结构简单处理\n        this.subscribers = new Set()\n    }\n    // 收集依赖\n    depend () {\n        if (activeUpdate) {\n            this.subscribers.add(activeUpdate)\n        }\n    }\n    // 派发更新\n    notify () {\n        this.subscribers.forEach(sub =&gt; sub())\n    }\n}\n// 响应式数据\nfunction observe (obj) {\n    Object.keys(obj).forEach(key =&gt; {\n        let internalValue = obj[key]\n        const dep = new Dep()\n        Object.defineProperty(obj, key, {\n            get () {\n                dep.depend()\n                return internalValue\n            },\n            set (newValue) {\n                // 是否更新条件\n                const changed = internalValue !== newValue\n                internalValue = newValue\n                if (changed) {\n                    dep.notify()\n                }\n            },\n\n        })\n\n    })\n}\n// 创建activeUpdate保存更新函数\nlet activeUpdate = null\n\nfunction autorun (update) {\n    activeUpdate = update\n    update()\n    activeUpdate = null\n    // const wrappedUpdate = () =&gt; {\n    //     activeUpdate = wrappedUpdate\n    //     update()\n    //     activeUpdate = null\n    // }\n    // wrappedUpdate()\n}\n\n\n\nconst state = {\n    count: 0,\n}\nobserve(state)\n// 自动函数 模拟访问或读取属性 此处模拟读取了count\nautorun(() =&gt; {\n    console.log(state.count)\n})\n// 打印&quot;count is: 0&quot;\n\nstate.count++\n// 打印&quot;count is: 1&quot;\n\n</code></pre>\n"},{"fileName":"vue拖拽指令.md","content":"<pre><code>Vue.directive(&#39;drag&#39;, {\n  // 1.指令绑定到元素上回立刻执行bind函数，只执行一次\n  // 2.每个函数中第一个参数永远是el，表示绑定指令的元素，el参数是原生js对象\n  // 3.通过el.focus()是无法获取焦点的，因为只有插入DOM后才生效\n  bind: function(el) {},\n  // inserted表示一个元素，插入到DOM中会执行inserted函数，只触发一次\n  inserted: function(el) {\n    const odiv = el // 获取当前元素\n    let firstTime = &#39;&#39;\n    let lastTime = &#39;&#39;\n    el.onmousedown = function(e) {\n      var disx = e.pageX - el.offsetLeft\n      var disy = e.pageY - el.offsetTop\n      // 给当前元素添加属性，用于元素状态的判断\n      odiv.setAttribute(&#39;ele-flag&#39;, false)\n      odiv.setAttribute(&#39;draging-flag&#39;, true)\n      firstTime = new Date().getTime()\n      document.onmousemove = function(e) {\n        el.style.left = e.pageX - disx + &#39;px&#39;\n        el.style.top = e.pageY - disy + &#39;px&#39;\n      }\n      document.onmouseup = function(event) {\n        document.onmousemove = document.onmouseup = null\n        lastTime = new Date().getTime()\n        if (lastTime - firstTime &gt; 200) {\n          odiv.setAttribute(&#39;ele-flag&#39;, true)\n          event.stopPropagation()\n        }\n        setTimeout(function() {\n          odiv.setAttribute(&#39;draging-flag&#39;, false)\n        }, 100)\n      }\n    }\n  },\n})\n</code></pre>\n"}]